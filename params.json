{"name":"Squall","tagline":"A streaming / online query processing / analytics engine based on Apache Storm","body":"\r\n<!--\r\n[alt text][logo]\r\n[logo]: https://raw.githubusercontent.com/epfldata/squall/master/resources/graphics/logo.jpg \"Logo Title Text 2\"\r\n-->\r\n\r\n#Squall [![Build Status](https://travis-ci.org/epfldata/squall.svg?branch=master)](https://travis-ci.org/epfldata/squall)\r\nSquall is an online query processing engine built on top of [Storm](https://storm.apache.org/). Similar to how Hive provides SQL syntax on top of Hadoop for doing batch processing, Squall executes SQL queries on top of Storm for doing online processing. Squall supports a wide class of SQL analytics ranging from simple aggregations to more advanced UDF join predicates and adaptive rebalancing of load. It is being actively developed by several contributors from the [EPFL DATA](http://data.epfl.ch/) lab. Squall is undergoing a continuous process of development, currently it supports the following:\r\n\r\n- [x] SQL (Select-Project-Join) query processing over continuous streams of data.\r\n- [x] Full fledged & full-history stateful computation essential for approximate query processing, e.g. [Online Aggregation](http://en.wikipedia.org/wiki/Online_aggregation).\r\n- [x] Time based Window Semantics for infinite data streams, e.g., sliding window, tumbling window, and landmark window semantics.\r\n- [x] Theta Joins: arbitrary complex join predicates, including inequality, band, and arbitrary UDF join predicates. This gives a more comprehensive support and flexibility to data analytics. For example, [Hive plans](https://cwiki.apache.org/confluence/display/Hive/Theta+Join) to support theta joins in response to user requests.\r\n- [x] Usability: Squall exposes three interfaces for programming. A **SQL** interface that directly translates a sql query to a running topology, a **functional** interface that leverages the syntactic sugar of Scala, and an **imperative** interface that exposes additional control on toplogy design.\r\n- [x] Out-of-Core Processing: Can operate efficiently under limited memory resources through efficient disk based datastructures and indexes.\r\n- [x] Throughput rates of upto Millions of tuples/second and latencies of milliseconds measured on a 16 machine cluster. Scalable to large cluster settings.\r\n- [x] Guarantees: At least-once or at most-once semantics. No support for exactly-once semantics yet, however it is planned for.\r\n- [ ] Elasticity: Scaling out according to the load.\r\n- [ ] DashBoard: Integrating support for real time visualizations.\r\n- [ ] Continuous load balance and adaptation to data skew.\r\n\r\n### Example:\r\nConsider the following SQL query:\r\n```sql\r\nSELECT C_MKTSEGMENT, COUNT(O_ORDERKEY)\r\nFROM CUSTOMER join ORDERS on C_CUSTKEY = O_CUSTKEY\r\nGROUP BY C_MKTSEGMENT\r\n```\r\n\r\nWe provide several interfaces for running this query:\r\n\r\n#### Declarative\r\nA Declarative interface that directly parses this SQL query and creates an efficient storm Topology. This module is implicitly equipped with a cost-based optimizer.\r\n#### Functional\r\nA Functional Scala-interface that leverages the brevity, productivity, convenience, and syntactic sugar of functional programming. For example the previous query is represented ([full code](https://github.com/epfldata/squall/blob/master/frontend/src/main/scala/frontend/functional/scala/queries/ScalaHyracksPlan.scala)) as follows: \r\n```scala\r\n    val customers = Source[customer](\"customer\").map { t => Tuple2(t._1, t._7) }\r\n    val orders = Source[orders](\"orders\").map { t => t._2 }\r\n    val join = customers.join(orders)(k1=> k1._1)(k2 => k2) //key1=key2\r\n    val agg = join.groupByKey(x => 1, k => k._1._2) //count and groupby\r\n    agg.execute(conf)\r\n```\r\n#### Imperative\r\nAn Imperative Java-interface that facilitates design and construction of online distributed query plans. For example the previous query is represented ([full code](https://github.com/epfldata/squall/blob/master/core/src/main/java/ch/epfl/data/plan_runner/query_plans/HyracksPlan.java)) as follows:\r\n\r\n```java\r\nComponent customer = new DataSourceComponent(\"customer\", conf)\r\n                            .add(new ProjectOperator(0, 6));\r\nComponent orders = new DataSourceComponent(\"orders\", conf)\r\n                            .add(new ProjectOperator(1));\r\nComponent custOrders = new EquiJoinComponent(customer, 0, orders, 0) //key1 (index 0) =key2 (index 0)\r\n                            .add(new AggregateCountOperator(conf).setGroupByColumns(1));\r\n```\r\n\r\nQueries are mapped to operator trees in the spirit of the query plans\r\nof relational database systems.\r\nThese are are in turn mapped to Storm workers. (There is a parallel\r\nimplementation of each operator, so in general an operator is processed\r\nby multiple workers).\r\nSome operations of relational algebra, such as selections and projections,\r\nare quite simple, and assigning them to separate workers is inefficient.\r\nRather than requiring the predecessor operator to send its output over the\r\nnetwork to the workers implementing these simple operations,\r\nthe simple operations can be integrated into the predecessor operators\r\nand postprocess the output there. This is typically also done in\r\nclassical relational database systems, but in a distributed environment,\r\nthe benefits are even greater.\r\nIn the Squall API, query plans are built bottom-up from \r\noperators (called components or super-operators)\r\nsuch as data source scans and joins; \r\nthese components can then be extended by postprocessing operators such as\r\nprojections.\r\n\r\n#### Window Semantics Example\r\nSquall also provides out-of-the-box functionality for window semantics. That is the user does not have to be concerned with internal details of assignining timestamps, data distribution and state maintenance and finally result consistency and correctness. Final results and aggregations are stored in key-value stores that expose window-identifiers and the corresponding timestamp ranges. The interface exposes the following semantics:\r\n\r\n* Sliding Window Semantics:\r\n```scala\r\n    //Examples\r\n    Agg.onWindow(20, 5) //Range 20 secs and slide every 5 seconds\r\n    Join.onSlidingWindow(10) // Range 10 seconds and slide every 1 second\r\n```\r\n\r\n* Tumbling Window Semantics:\r\n```scala\r\n    //Examples\r\n    Agg.onTumblingWindow(20) // Tumble aggregations every 20 seconds\r\n``` \r\n\r\n* Landmark Window Semantics.\r\n\r\n[Here](https://github.com/epfldata/squall/blob/master/frontend/src/main/scala/frontend/functional/scala/queries/ScalaTPCH7Plan.scalaz) is an example of a fully running query with window semantics.\r\n\r\n\r\n\r\n\r\n### Documentation\r\nDetailed documentation can be found on the [Squall wiki](http://github.com/epfldata/squall/wiki).\r\n\r\n### Contributing to Squall\r\nWe'd love to have your help in making Squall better. If you're interested, please communicate with us your suggestions and get your name to the [Contributors](https://github.com/epfldata/squall/wiki/Contributors) list.\r\n\r\n### License\r\nSquall is licensed under [Apache License v2.0](http://www.apache.org/licenses/LICENSE-2.0.html).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}